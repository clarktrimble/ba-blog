
## Backstory

A few years back, I had the good fortune to attent a developer summit in San Jose.
For remote teams, these things are a tonic; sharing of food and drink engages a primal goodness.
In the course of our meetings during the day, we picked over the particulars of whatever issues with which we were immediatly faced.
Some of the decisions we reached even survived the vicissitudes of our organization in the coming months :)



A week before the summit, a little to my surprise, I learned of a reading assignment, "Clean Archictexture".
Cool; my copy arrived a few days before and I read it on the plane.
So yeah, skimmed it.
We didn't have a chance to discuss the book at the summit.

However, something from that book stuck.
Amidst the surely typical, fire-fighting, meetings, and compelling new projects, a few of the concepts percolated.
I began to apply some of them in the code, rather ham-fistedly to begin with.
The ideas continued to stick and I stuck with experimenting with them at the margin.

## Entity

From the book ...

Biz-logics ...

"That which does not depend on other that the standard library."

That's it! Group this kind of code and voila! a simple to understand simple to apply technique.
Other code relative to this.

## Organization

"organizing principles"

Having a pattern that holds together.
Not necessarily more correct than other patterns.

Freedom to concentrate elsewhere, but:
Freedom to experiment.
Discussion rather than proscription.

Scale, scale, scale - bigger scale -> more rules

Simple to apply.


## Notes

Not https://github.com/golang-standards/project-layout

Service-layer and dependency injecttion, next time!

From the start Golang has had a minimalist culture wrt code organiztion.
 - un package "dont change the interface"
